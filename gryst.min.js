"use strict"; var gryst = gryst || {}; gryst.logging = !1, gryst.log = function (a) { gryst.logging && console.log(a) }, gryst.agg = { max: function (a, b) { var c = a; return b && (c = [], a.forEach(function (d, e) { c[e] = a[e][b] })), Math.max.apply(this, c) }, min: function (a, b) { var c = a; return b && (c = [], a.forEach(function (d, e) { c[e] = a[e][b] })), Math.min.apply(this, c) }, avg: function (a, b) { var c = 0, d = 0; return a.forEach(function (a) { c++, d += null === a[b] ? 0 : a[b] }), d / c } }, gryst.common = { getParamNames: function (a) { var b = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm, c = /([^\s,]+)/g, d = a.toString().replace(b, ""), e = d.slice(d.indexOf("(") + 1, d.indexOf(")")).match(c); return null === e && (e = []), e }, hasValue: function (a) { return "undefined" != typeof a && null !== a }, isEmpty: function (a) { return "undefined" == typeof a || null === a }, countProps: function (a) { var b, c = 0; for (b in a) a.hasOwnProperty(b) && c++; return c }, deepEqual: function (a, b) { var c, d; if (typeof a != typeof b) return !1; if ("function" == typeof a) return a.toString() === b.toString(); if (a instanceof Object) { if (gryst.common.countProps(a) !== gryst.common.countProps(b)) return !1; for (c in a) if (d = gryst.common.deepEqual(a[c], b[c]), !d) return !1; return !0 } return a === b }, getFieldRefs: function (a, b, c) { var d = [], e = Array.isArray(a) ? a : a.split(","); return e.forEach(function (a) { "$" != a[0] && d.push(new gryst.FieldRef(a, b, c)) }), d }, getArguments: function (a, b) { var c = []; return a.forEach(function (a) { c.push(a.getArgForMapping(b)) }), c }, getType: function (a) { return null === a ? null : a instanceof Date ? "date" : Array.isArray(a) ? "array" : typeof a }, l: "abcdefghijklmnopqrstuvwxyz", createTableID: function (a, b) { b = b || ""; for (var c, d = 0; d < gryst.common.l.length; d++) if (c = b + gryst.common.l[d], !(c in a)) return c; return gryst.common.createTableID(a, b + "a") } }, gryst.common.stringify = JSON.stringify || function (a) { var b, c, d, e = []; switch (b = gryst.common.getType(a)) { case null: e.push("null"); break; case "number": case "boolean": e.push(a); break; case "string": e.push('"' + a + '"'); break; case "date": e.push("Date(" + a.getTime() + ")"); break; case "array": for (e.push("["), c = 0; c < a.length; c++) c > 0 && e.push(","), e.push(gryst.common.stringify(a[c])); e.push("]"); break; case "object": for (d = Object.getOwnPropertyNames(a), e.push("{"), c = 0; c < d.length; c++) c > 0 && e.push(","), e.push('"' + d[c] + '":'), e.push(gryst.common.stringify(a[d[c]])); e.push("}"); break; default: throw "Could not determine type: " + a } return e.join("") }, function (a) { gryst.Distinct = function (a, b, c, d) { this.func = a, this.tables = b, this.getJoinMap = c, this.setJoinMap = d }, gryst.Distinct.$inject = ["$tables", "$getJoinMap", "$setJoinMap"], gryst.Distinct.prototype = { run: function () { var b = this.getJoinMap(); if (0 === b.length) return gryst.log("Distinct: no map"), b; var c, d, e, f = this, g = [], h = Object.getOwnPropertyNames(b[0]); return this.func ? (gryst.log("Distinct: using supplied function"), e = [], 1 === h.length ? b.forEach(function (a) { d = f.tables[h[0]][a[h[0]]], c = !1; for (var b = e.length - 1; b >= 0 && c === !1; b--) c = f.func(e[b], d); c === !1 && (e.push(d), g.push(a)) }) : b.forEach(function (a) { d = {}, h.forEach(function (b) { d[b] = f.tables[b][a[b]] }), c = !1; for (var b = e.length - 1; b >= 0 && c === !1; b--) c = f.func(e[b], d); c === !1 && (e.push(d), g.push(a)) })) : (gryst.log("Distinct: no arguments, operating against entire map"), e = {}, 1 === h.length ? b.forEach(function (b) { d = f.tables[h[0]][b[h[0]]], d = a.stringify(d), e[d] = b }) : b.forEach(function (b) { d = {}, h.forEach(function (a) { d[a] = f.tables[a][b[a]] }), d = a.stringify(d), e[d] = b }), Object.getOwnPropertyNames(e).forEach(function (a) { g.push(e[a]) })), this.setJoinMap(g), g } } }(gryst.common), function () { gryst.FieldRef = function (a, b, c) { var d, e; this.id = null, this.field = null, this.index = null, this.table = null, this.name = null, void 0 === c && (c = !0), this.getArgForRow = function (a) { return a[this.field] }; var f = a.replace(/ /g, ""); if (-1 != f.indexOf(".")) return e = f.split("."), this.id = e[0], this.field = e[1], this.table = b[this.id], this.name = this.field, this; if (-1 != f.indexOf("[")) return e = f.split("["), this.id = e[0], this.index = parseInt(f.match(/\d+/)), this.table = b[this.id], this.getArgForRow = function (a) { return a[this.index] }, this.name = this.id + "_" + this.index, this; if (void 0 != b[f]) return this.id = f, this.table = b[this.id], this.getArgForRow = function (a) { return a }, this.name = this.id, this; var g = Object.getOwnPropertyNames(b); for (d = 0; d < g.length; d++) if (b[g[d]].length > 0 && void 0 != b[g[d]][0][f]) return this.id = g[d], this.field = f, this.table = b[g[d]], this.name = this.field, this; if (c) throw "Could not resolve field reference: " + a }, gryst.FieldRef.prototype = { isResolved: function () { return null != this.table }, getArg: function (a) { var b = this.table[a]; return this.getArgForRow(b) }, getArgForMapping: function (a) { var b = this.table[a[this.id]]; return this.getArgForRow(b) }, getMap: function () { var a, b = this, c = {}; return this.table.forEach(function (d, e) { a = b.getArgForRow(d), Array.isArray(c[a]) ? c[a].push(e) : c[a] = [e] }), c } } }(), function (a) { gryst.from = function (a, b) { return (new gryst.Query).from(a, b) }, gryst.From = function (a, b, c, d) { this.tableID = a, this.tables = b, this.getJoinMap = c, this.setJoinMap = d }, gryst.From.$inject = ["$tables", "$getJoinMap", "$setJoinMap"], gryst.From.prototype = { run: function () { gryst.log("From: tableID: " + this.tableID); var b, c, d, a = this, e = this.getJoinMap(), f = this.tables[this.tableID]; if (void 0 === f) throw "From: table is undefined"; return 0 != e.length ? (gryst.log("From: cross join"), d = [], e.forEach(function (e) { b = Object.getOwnPropertyNames(e), f.forEach(function (f, g) { c = {}, b.forEach(function (a) { c[a] = e[a] }), c[a.tableID] = g, d.push(c) }) }), gryst.log("From: new join map length: " + d.length), this.setJoinMap(d), d) : (gryst.log("From: creating join map"), f.forEach(function (b, d) { c = {}, c[a.tableID] = d, e.push(c) }), gryst.log("From: join map length: " + e.length), e) } } }(gryst.common), function (a) { gryst.Group = function (b, c, d, e, f, g) { this.tables = e, this.getJoinMap = f, this.setJoinMap = g, this.tableID = d, "function" == typeof b ? (this.groupFunc = b, this.groupFuncParams = a.getParamNames(b)) : this.groupFuncParams = b, "function" == typeof c ? (this.keyFunc = c, this.keyFuncParams = a.getParamNames(c)) : this.keyFuncParams = c }, gryst.Group.$inject = ["$tables", "$getJoinMap", "$setJoinMap"], gryst.Group.prototype = { run: function () { this.tables[this.tableID] = []; var b = this.getJoinMap(); if (0 == b.length) return gryst.log("Group: empty join map"), this.tables[this.tableID]; var d, e, f, g, c = this, h = a.getFieldRefs(this.keyFuncParams, this.tables), i = a.getFieldRefs(this.groupFuncParams, this.tables), j = new gryst.Grouping; return this.keyFunc ? (gryst.log("Group: using supplied function"), b.forEach(function (b) { d = a.getArguments(h, b), f = c.keyFunc.apply(c, d), j.addKey(f, b) })) : (gryst.log("Group: using keyFields:"), gryst.log(h), b.forEach(function (a) { 1 === h.length ? f = h[0].getArgForMapping(a) : (f = {}, h.forEach(function (b) { f[b.name] = b.getArgForMapping(a) })), j.addKey(f, a) })), this.tables[this.tableID] = j.getResult(i, this.groupFunc), g = [], this.tables[this.tableID].forEach(function (a, b) { e = {}, e[c.tableID] = b, g.push(e) }), this.setJoinMap(g), this.tables[this.tableID] } } }(gryst.common), function (a) { gryst.Grouping = function () { this.keys = [], this.coerced = [], this.map = {} }; var b = { getArgs: function (b, c) { var d, e = []; return c.forEach(function (c) { d = a.getArguments(b, c), d = 1 == d.length ? d[0] : d, e.push(d) }), e } }; gryst.Grouping.prototype = { addKey: function (b, c) { var d = "object" == typeof b ? a.stringify(b) : b; Array.isArray(this.map[d]) ? this.map[d].push(c) : (this.map[d] = [c], this.keys.push(b), this.coerced.push(d)) }, getResult: function (a, c) { var d, e, f, g, h, i, j = []; if (c) for (h = 0; h < this.keys.length; h++) i = this.coerced[h], d = this.map[i], e = b.getArgs(a, d), g = 1 == a.length ? c.call(gryst.agg, e) : c.apply(gryst.agg, e), j.push({ key: this.keys[h], values: g }); else for (h = 0; h < this.keys.length; h++) i = this.coerced[h], d = this.map[i], e = b.getArgs(a, d), g = [], e.forEach(function (b) { f = {}, a.forEach(function (a, c) { void 0 != a.field ? f[a.field] = b[c] : f = b }), g.push(f) }), j.push({ key: this.keys[h], values: g }); return j } } }(gryst.common), function () { gryst.Injector = function (a) { this.dep = { $tables: a.tables, $getMap: function (b, c) { return a.getMap(b, c) }, $getJoinMap: function () { return a.joinMap }, $setJoinMap: function (b) { a.joinMap = b }, $agg: gryst.agg, $injector: this } }, gryst.Injector.prototype = { inject: function (a, b) { b = b || []; var c, d = this; return a.$inject ? a.$inject.forEach(function (a) { if (!d.dep.hasOwnProperty(a)) throw "Unrecognized dependency: " + a; b.push(d.dep[a]) }) : (c = gryst.common.getParamNames(a), c.forEach(function (a) { d.dep.hasOwnProperty(a) && b.push(d.dep[a]) })), b } } }(), function (a) { gryst.Join = function (b, c, d, e, f) { if (this.tables = d, this.getJoinMap = e, this.setJoinMap = f, a.isEmpty(b) || a.isEmpty(c)) throw "Join is missing field references."; this.field1 = b, this.field2 = c }, gryst.Join.$inject = ["$tables", "$getJoinMap", "$setJoinMap"]; var b = { setFieldReferences: function (a) { if (a.length > 0) if (a[0].hasOwnProperty(this.fieldRef1.id)) this.leftField = this.fieldRef1, this.rightField = this.fieldRef2; else { if (!a[0].hasOwnProperty(this.fieldRef2.id)) throw "Join failed: unable to resolve field references: " + this.field1 + "," + this.field2; this.leftField = this.fieldRef2, this.rightField = this.fieldRef1 } } }; gryst.Join.prototype = { run: function () { var a = this.getJoinMap(); if (0 == a.length) return gryst.log("Join: empty join map"), a; this.fieldRef1 = new gryst.FieldRef(this.field1, this.tables), this.fieldRef2 = new gryst.FieldRef(this.field2, this.tables), b.setFieldReferences.call(this, a), gryst.log("Join: left field:"), gryst.log(this.leftField), gryst.log("Join: right field:"), gryst.log(this.rightField); var e, f, g, i, c = this, h = [], j = this.rightField.getMap(); return i = Object.getOwnPropertyNames(a[0]), a.forEach(function (a) { g = c.leftField.getArgForMapping(a), e = j[g], e && (a[c.rightField.id] = e[0], h.push(a), e.length > 1 && (e.shift(), e.forEach(function (b) { f = {}, i.forEach(function (b) { f[b] = a[b] }), f[c.rightField.id] = b, h.push(f) }))) }), this.setJoinMap(h), h } } }(gryst.common), function () { gryst.JoinMap = function (a, b) { var c = this; this.tables = b, this.map = a, this.run = function () { var a, b, d = [], e = this.map.length > 0 ? Object.getOwnPropertyNames(this.map[0]) : null; return e && (1 == e.length ? (a = e[0], this.map.forEach(function (e) { b = c.tables[a][e[a]], d.push(b) })) : this.map.forEach(function (a) { b = {}, e.forEach(function (d) { b[d] = c.tables[d][a[d]] }), d.push(b) })), d } }, gryst.JoinMap.$inject = ["$tables"] }(), function (a) { gryst.extend = function (a, c, d) { d && (c.$inject = d), gryst.Query.prototype[a] = function (a) { var d = b.createOp.call(this, c, a); return this.ops.push(d), this } }, gryst.Query = function () { var a = this; this.tables = {}, this.joinMap = [], this.ops = [], this.result = null, this.injector = new gryst.Injector(this), Object.defineProperty(this, "length", { get: function () { return null === a.result && a.run(), a.result.length } }) }; var b = { createOp: function (a, b) { return b = Array.isArray(b) ? b : [b], this.injector.inject(a, b), new a(b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8], b[9]) }, addChildSort: function (a) { for (var b = this.ops.length - 1; b >= 0; b--) if (this.ops[b] instanceof gryst.Sort) return void this.ops[b].setChild(a); this.ops.push(a) }, run: function () { var a = this; return this.joinMap = [], this.result = null, this.ops.forEach(function (b) { a.result = b.run() }), this.result === this.joinMap && (this.result = new gryst.JoinMap(this.joinMap, this.tables).run()), this.result } }; gryst.Query.prototype = { from: function (c, d) { d = d || a.createTableID(this.tables), this.tables[d] = c; var e = b.createOp.call(this, gryst.From, d); return this.ops.push(e), this }, join: function (a, c, d, e) { this.tables[c] = a; var f = b.createOp.call(this, gryst.Join, [d, e]); return this.ops.push(f), this }, where: function (a) { var c = b.createOp.call(this, gryst.Where, a); return this.ops.push(c), this }, orderBy: function (a, c) { var d = b.createOp.call(this, gryst.Sort, [a, !1, c]); return this.ops.push(d), this }, thenBy: function (a, c) { var d = b.createOp.call(this, gryst.Sort, [a, !1, c]); return b.addChildSort.call(this, d), this }, orderByDescending: function (a, c) { var d = b.createOp.call(this, gryst.Sort, [a, !0, c]); return this.ops.push(d), this }, thenByDescending: function (a, c) { var d = b.createOp.call(this, gryst.Sort, [a, !0, c]); return b.addChildSort.call(this, d), this }, group: function (a, c, d) { var e = b.createOp.call(this, gryst.Group, [a, c, d]); return this.ops.push(e), this }, select: function (a, c) { var d = b.createOp.call(this, gryst.Select, [a, c]); return this.ops.push(d), this }, distinct: function (a) { var c = b.createOp.call(this, gryst.Distinct, a); return this.ops.push(c), this }, forEach: function (a) { var b = this, c = this.run(); c.forEach(function (c, d) { a.call(b, c, d) }) }, run: function (a) { if (void 0 == a) return b.run.call(this); var c = this; setTimeout(function () { a(b.run.call(c)) }, 0) }, get: function (a) { return null === this.result && this.run(), this.result[a] } } }(gryst.common), function (a) { gryst.Select = function (b, c, d, e, f) { if (this.tables = d, this.getJoinMap = e, this.setJoinMap = f, this.tableID = c, "function" == typeof b) { if (this.func = b, this.params = a.getParamNames(b), 0 === this.params.length) throw "Select function has no parameters." } else this.params = b }, gryst.Select.$inject = ["$tables", "$getJoinMap", "$setJoinMap"], gryst.Select.prototype = { run: function () { var c, d, e, b = this, f = [], g = this.getJoinMap(); if (this.tableID = this.tableID || a.createTableID(this.tables), gryst.log("Select: table ID:" + this.tableID), this.tables[this.tableID] = [], 0 == g.length) return gryst.log("Select: empty join map"), this.tables[this.tableID]; gryst.log("Select: params:"), gryst.log(this.params), gryst.log("Select: tables:"), gryst.log(this.tables); var h = a.getFieldRefs(this.params, this.tables); return gryst.log("Select: fields:"), gryst.log(h), this.func ? g.forEach(function (c) { e = a.getArguments(h, c), d = b.func.apply(b, e), b.tables[b.tableID].push(d) }) : g.forEach(function (a) { c = {}, 1 == h.length ? c = h[0].getArgForMapping(a) : h.forEach(function (b) { c[b.name] = b.getArgForMapping(a) }), b.tables[b.tableID].push(c) }), this.tables[this.tableID].forEach(function (a, d) { c = {}, c[b.tableID] = d, f.push(c) }), this.setJoinMap(f), this.tables[this.tableID] } } }(gryst.common), gryst.extend("skip", function (a, b, c) { this.run = function () { gryst.log("skip: " + a); var d = b().slice(a); return c(d), d } }, ["$getJoinMap", "$setJoinMap"]), gryst.extend("take", function (a, b, c) { this.run = function () { gryst.log("take: " + a); var d = b().slice(0, a); return c(d), d } }, ["$getJoinMap", "$setJoinMap"]), function (a) { gryst.Sort = function (a, b, c, d, e, f) { this.field = a, this.desc = b, this.func = c, this.tables = d, this.getJoinMap = e, this.setJoinMap = f, this.childSort = null, this.type = null, this.fieldRef = null, this.sort = null }, gryst.Sort.$inject = ["$tables", "$getJoinMap", "$setJoinMap"]; var b = { getSortType: function (b) { var c, d, e; if (b.table.length > 0) { for (e = null, c = 0; c < b.table.length && a.isEmpty(e) ; c++) e = b.getArg(c); if (!a.isEmpty(e)) switch (d = a.getType(e), gryst.log("Sort: key type: "), gryst.log(d), d) { case "number": case "date": case "boolean": return d; default: return "string" } } }, getSortFunction: function () { var a, c = this; return gryst.log("Sort: resolving sort function"), this.fieldRef = new gryst.FieldRef(this.field, this.tables), gryst.log("Sort: fieldRef:"), gryst.log(this.fieldRef), void 0 != this.func ? (gryst.log("Sort: using supplied function"), function (a, b) { var d = c.fieldRef.getArgForMapping(a), e = c.fieldRef.getArgForMapping(b), f = c.func(d, e); return 0 === f && null !== c.childSort ? c.childSort.sort(a, b) : f }) : (a = b.getSortType(this.fieldRef), "number" === a || "date" === a || "boolean" == a ? (gryst.log("Sort: sorting by number || date || boolean"), this.desc === !0 ? function (a, b) { var d = c.fieldRef.getArgForMapping(a), e = c.fieldRef.getArgForMapping(b), f = e - d; return 0 === f && null !== c.childSort ? c.childSort.sort(a, b) : f } : function (a, b) { var d = c.fieldRef.getArgForMapping(a), e = c.fieldRef.getArgForMapping(b), f = d - e; return 0 === f && null !== c.childSort ? c.childSort.sort(a, b) : f }) : (gryst.log("Sort: sorting by string"), this.desc === !0 ? function (a, b) { var d = c.fieldRef.getArgForMapping(a), e = c.fieldRef.getArgForMapping(b); if (null === d) { if (null != e) return 1 } else if (null === e) return -1; return d > e ? -1 : e > d ? 1 : null !== c.childSort ? c.childSort.sort(a, b) : 0 } : function (a, b) { var d = c.fieldRef.getArgForMapping(a), e = c.fieldRef.getArgForMapping(b); if (null === d) { if (null != e) return -1 } else if (null === e) return 1; return d > e ? 1 : e > d ? -1 : null !== c.childSort ? c.childSort.sort(a, b) : 0 })) } }; gryst.Sort.prototype = { setChild: function (a) { null === this.childSort ? this.childSort = a : this.childSort.setChild(a) }, init: function () { this.sort = b.getSortFunction.call(this), null !== this.childSort && this.childSort.init() }, run: function () { var a = this.getJoinMap(); return a.length < 2 ? (gryst.log("Sort: empty join map"), a) : (this.init(), gryst.log("Sort: desc: "), gryst.log(this.desc), a.sort(this.sort), a) } } }(gryst.common), function (a) { gryst.Where = function (b, c, d, e) { if (this.tables = c, this.getJoinMap = d, this.setJoinMap = e, this.func = b, this.params = a.getParamNames(b), this.throwIfNoFieldRef = this.params.length > 1, 0 === this.params.length) throw "Where function has no parameters." }, gryst.Where.$inject = ["$tables", "$getJoinMap", "$setJoinMap"], gryst.Where.prototype = { run: function () { var b = this.getJoinMap(); if (0 == b.length) return gryst.log("Where: empty join map"), b; var d, e, c = [], f = this; gryst.log("Where: throw if no field refs: " + this.throwIfNoFieldRef); var g = a.getFieldRefs(this.params, this.tables, this.throwIfNoFieldRef); if (gryst.log("Where: fieldRefs:"), gryst.log(g), 1 === g.length && g[0].isResolved() === !1) { var h = Object.getOwnPropertyNames(this.tables).sort().reverse()[0]; if (g[0] = new gryst.FieldRef(h, this.tables), g[0].isResolved() === !1) throw "Could not resolve field references for where clause: " + this.params.toString() } return gryst.log("Where: fieldRefs:"), gryst.log(g), b.forEach(function (b) { d = a.getArguments(g, b), e = f.func.apply(f, d), e === !0 && c.push(b) }), this.setJoinMap(c), c } } }(gryst.common);