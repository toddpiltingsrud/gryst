"use strict"; var gryst = gryst || {}; gryst.logging = !1; gryst.log = function (n) { gryst.logging && console.log(n) }; gryst.agg = { max: function (n, t) { var i = n; return t && (i = [], n.forEach(function (r, u) { i[u] = n[u][t] })), Math.max.apply(this, i) }, min: function (n, t) { var i = n; return t && (i = [], n.forEach(function (r, u) { i[u] = n[u][t] })), Math.min.apply(this, i) }, avg: function (n, t) { var i = 0, r = 0; return n.forEach(function (n) { i++; r += n[t] === null ? 0 : n[t] }), r / i } }; gryst.common = { getParamNames: function (n) { var t = n.toString().replace(/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg, ""), i = t.slice(t.indexOf("(") + 1, t.indexOf(")")).match(/([^\s,]+)/g); return i === null && (i = []), i }, hasValue: function (n) { return typeof n != "undefined" && n !== null }, isEmpty: function (n) { return typeof n == "undefined" || n === null }, countProps: function (n) { var t, i = 0; for (t in n) n.hasOwnProperty(t) && i++; return i }, deepEqual: function (n, t) { var i, r; if (typeof n != typeof t) return !1; if (typeof n == "function") return n.toString() === t.toString(); if (n instanceof Object) { if (gryst.common.countProps(n) !== gryst.common.countProps(t)) return !1; for (i in n) if (r = gryst.common.deepEqual(n[i], t[i]), !r) return !1; return !0 } return n === t }, getFieldRefs: function (n, t, i) { var r = [], u = Array.isArray(n) ? n : n.split(","); return u.forEach(function (n) { n[0] != "$" && r.push(new gryst.FieldRef(n, t, i)) }), r }, getArguments: function (n, t) { var i = []; return n.forEach(function (n) { i.push(n.getArgForMapping(t)) }), i }, getType: function (n) { return n === null ? null : n instanceof Date ? "date" : Array.isArray(n) ? "array" : typeof n }, l: "abcdefghijklmnopqrstuvwxyz", createTableID: function (n, t) { var r, i; for (t = t || "", i = 0; i < gryst.common.l.length; i++) if (r = t + gryst.common.l[i], !(r in n)) return r; return gryst.common.createTableID(n, t + "a") } }; gryst.common.stringify = JSON.stringify || function (n) { var u, i, r, t = []; u = gryst.common.getType(n); switch (u) { case null: t.push("null"); break; case "number": case "boolean": t.push(n); break; case "string": t.push('"' + n + '"'); break; case "date": t.push("Date(" + n.getTime() + ")"); break; case "array": for (t.push("["), i = 0; i < n.length; i++) i > 0 && t.push(","), t.push(gryst.common.stringify(n[i])); t.push("]"); break; case "object": for (r = Object.getOwnPropertyNames(n), t.push("{"), i = 0; i < r.length; i++) i > 0 && t.push(","), t.push('"' + r[i] + '":'), t.push(gryst.common.stringify(n[r[i]])); t.push("}"); break; default: throw "Could not determine type: " + n; } return t.join("") }, function (n) { gryst.Distinct = function (n, t, i, r) { this.func = n; this.tables = t; this.getJoinMap = i; this.setJoinMap = r }; gryst.Distinct.$inject = ["$tables", "$getJoinMap", "$setJoinMap"]; gryst.Distinct.prototype = { run: function () { var e = this.getJoinMap(); if (e.length === 0) return gryst.log("Distinct: no map"), e; var u, t, r, o = this, s = [], f = Object.getOwnPropertyNames(e[0]); return this.func ? (gryst.log("Distinct: using supplied function"), r = [], f.length === 1 ? e.forEach(function (n) { for (t = o.tables[f[0]][n[f[0]]], u = !1, i = r.length - 1; i >= 0 && u === !1; i--) u = o.func(r[i], t); u === !1 && (r.push(t), s.push(n)) }) : e.forEach(function (n) { for (t = {}, f.forEach(function (i) { t[i] = o.tables[i][n[i]] }), u = !1, i = r.length - 1; i >= 0 && u === !1; i--) u = o.func(r[i], t); u === !1 && (r.push(t), s.push(n)) })) : (gryst.log("Distinct: no arguments, operating against entire map"), r = {}, f.length === 1 ? e.forEach(function (i) { t = o.tables[f[0]][i[f[0]]]; t = n.stringify(t); r[t] = i }) : e.forEach(function (i) { t = {}; f.forEach(function (n) { t[n] = o.tables[n][i[n]] }); t = n.stringify(t); r[t] = i }), Object.getOwnPropertyNames(r).forEach(function (n) { s.push(r[n]) })), this.setJoinMap(s), s } } }(gryst.common), function () { gryst.FieldRef = function (n, t, i) { var u, e, r, f; if (this.id = null, this.field = null, this.index = null, this.table = null, this.name = null, i === undefined && (i = !0), this.getArgForRow = function (n) { return n[this.field] }, r = n.replace(/ /g, ""), r.indexOf(".") != -1) return e = r.split("."), this.id = e[0], this.field = e[1], this.table = t[this.id], this.name = this.field, this; if (r.indexOf("[") != -1) return e = r.split("["), this.id = e[0], this.index = parseInt(r.match(/\d+/)), this.table = t[this.id], this.getArgForRow = function (n) { return n[this.index] }, this.name = this.id + "_" + this.index, this; if (t[r] != undefined) return this.id = r, this.table = t[this.id], this.getArgForRow = function (n) { return n }, this.name = this.id, this; for (f = Object.getOwnPropertyNames(t), u = 0; u < f.length; u++) if (t[f[u]].length > 0 && t[f[u]][0][r] != undefined) return this.id = f[u], this.field = r, this.table = t[f[u]], this.name = this.field, this; if (i) throw "Could not resolve field reference: " + n; }; gryst.FieldRef.prototype = { isResolved: function () { return this.table != null }, getArg: function (n) { var t = this.table[n]; return this.getArgForRow(t) }, getArgForMapping: function (n) { var t = this.table[n[this.id]]; return this.getArgForRow(t) }, getMap: function () { var n, i = this, t = {}; return this.table.forEach(function (r, u) { n = i.getArgForRow(r); Array.isArray(t[n]) ? t[n].push(u) : t[n] = [u] }), t } } }(), function () { gryst.from = function (n, t) { return (new gryst.Query).from(n, t) }; gryst.From = function (n, t, i, r) { this.tableID = n; this.tables = t; this.getJoinMap = i; this.setJoinMap = r }; gryst.From.$inject = ["$tables", "$getJoinMap", "$setJoinMap"]; gryst.From.prototype = { run: function () { gryst.log("From: tableID: " + this.tableID); var u = this, f, n, t, i = this.getJoinMap(), r = this.tables[this.tableID]; if (r === undefined) throw "From: table is undefined"; if (i.length == 0) gryst.log("From: creating join map"), r.forEach(function (t, r) { n = {}; n[u.tableID] = r; i.push(n) }), gryst.log("From: join map length: " + i.length); else return gryst.log("From: cross join"), t = [], i.forEach(function (i) { f = Object.getOwnPropertyNames(i); r.forEach(function (r, e) { n = {}; f.forEach(function (t) { n[t] = i[t] }); n[u.tableID] = e; t.push(n) }) }), gryst.log("From: new join map length: " + t.length), this.setJoinMap(t), t; return i } } }(gryst.common), function (n) { gryst.Group = function (t, i, r, u, f, e) { this.tables = u; this.getJoinMap = f; this.setJoinMap = e; this.tableID = r; typeof t == "function" ? (this.groupFunc = t, this.groupFuncParams = n.getParamNames(t)) : this.groupFuncParams = t; typeof i == "function" ? (this.keyFunc = i, this.keyFuncParams = n.getParamNames(i)) : this.keyFuncParams = i }; gryst.Group.$inject = ["$tables", "$getJoinMap", "$setJoinMap"]; gryst.Group.prototype = { run: function () { var r; if (this.tables[this.tableID] = [], r = this.getJoinMap(), r.length == 0) return gryst.log("Group: empty join map"), this.tables[this.tableID]; var u = this, s, f, t, e, i = n.getFieldRefs(this.keyFuncParams, this.tables), h = n.getFieldRefs(this.groupFuncParams, this.tables), o = new gryst.Grouping; return this.keyFunc ? (gryst.log("Group: using supplied function"), r.forEach(function (r) { s = n.getArguments(i, r); t = u.keyFunc.apply(u, s); o.addKey(t, r) })) : (gryst.log("Group: using keyFields:"), gryst.log(i), r.forEach(function (n) { i.length === 1 ? t = i[0].getArgForMapping(n) : (t = {}, i.forEach(function (i) { t[i.name] = i.getArgForMapping(n) })); o.addKey(t, n) })), this.tables[this.tableID] = o.getResult(h, this.groupFunc), e = [], this.tables[this.tableID].forEach(function (n, t) { f = {}; f[u.tableID] = t; e.push(f) }), this.setJoinMap(e), this.tables[this.tableID] } } }(gryst.common), function (n) { gryst.Grouping = function () { this.keys = []; this.coerced = []; this.map = {} }; var t = { getArgs: function (t, i) { var r, u = []; return i.forEach(function (i) { r = n.getArguments(t, i); r = r.length == 1 ? r[0] : r; u.push(r) }), u } }; gryst.Grouping.prototype = { addKey: function (t, i) { var r = typeof t == "object" ? n.stringify(t) : t; Array.isArray(this.map[r]) ? this.map[r].push(i) : (this.map[r] = [i], this.keys.push(t), this.coerced.push(r)) }, getResult: function (n, i) { var e, u, o, f, r, s, h = []; if (i) for (r = 0; r < this.keys.length; r++) s = this.coerced[r], e = this.map[s], u = t.getArgs(n, e), f = n.length == 1 ? i.call(gryst.agg, u) : i.apply(gryst.agg, u), h.push({ key: this.keys[r], values: f }); else for (r = 0; r < this.keys.length; r++) s = this.coerced[r], e = this.map[s], u = t.getArgs(n, e), f = [], u.forEach(function (t) { o = {}; n.forEach(function (n, i) { n.field != undefined ? o[n.field] = t[i] : o = t }); f.push(o) }), h.push({ key: this.keys[r], values: f }); return h } } }(gryst.common), function () { gryst.Injector = function (n) { this.dep = { $tables: n.tables, $getMap: function (t, i) { return n.getMap(t, i) }, $getJoinMap: function () { return n.joinMap }, $setJoinMap: function (t) { n.joinMap = t }, $agg: gryst.agg, $injector: this } }; gryst.Injector.prototype = { inject: function (n, t) { t = t || []; var r, i = this; return n.$inject ? n.$inject.forEach(function (n) { if (i.dep.hasOwnProperty(n)) t.push(i.dep[n]); else throw "Unrecognized dependency: " + n; }) : (r = gryst.common.getParamNames(n), r.forEach(function (n) { i.dep.hasOwnProperty(n) && t.push(i.dep[n]) })), t } } }(), function (n) { gryst.Join = function (t, i, r, u, f) { if (this.tables = r, this.getJoinMap = u, this.setJoinMap = f, n.isEmpty(t) || n.isEmpty(i)) throw "Join is missing field references."; this.field1 = t; this.field2 = i }; gryst.Join.$inject = ["$tables", "$getJoinMap", "$setJoinMap"]; var t = { setFieldReferences: function (n) { if (n.length > 0) if (n[0].hasOwnProperty(this.fieldRef1.id)) this.leftField = this.fieldRef1, this.rightField = this.fieldRef2; else if (n[0].hasOwnProperty(this.fieldRef2.id)) this.leftField = this.fieldRef2, this.rightField = this.fieldRef1; else throw "Join failed: unable to resolve field references: " + this.field1 + "," + this.field2; } }; gryst.Join.prototype = { run: function () { var i = this.getJoinMap(); if (i.length == 0) return gryst.log("Join: empty join map"), i; this.fieldRef1 = new gryst.FieldRef(this.field1, this.tables); this.fieldRef2 = new gryst.FieldRef(this.field2, this.tables); t.setFieldReferences.call(this, i); gryst.log("Join: left field:"); gryst.log(this.leftField); gryst.log("Join: right field:"); gryst.log(this.rightField); var f = this, n, r, e, u = [], o, s = this.rightField.getMap(); return o = Object.getOwnPropertyNames(i[0]), i.forEach(function (t) { e = f.leftField.getArgForMapping(t); n = s[e]; n && (t[f.rightField.id] = n[0], u.push(t), n.length > 1 && (n.shift(), n.forEach(function (n) { r = {}; o.forEach(function (n) { r[n] = t[n] }); r[f.rightField.id] = n; u.push(r) }))) }), this.setJoinMap(u), u } } }(gryst.common), function () { gryst.JoinMap = function (n, t) { var i = this; this.tables = t; this.map = n; this.run = function () { var r, n, u = [], t = this.map.length > 0 ? Object.getOwnPropertyNames(this.map[0]) : null; return t && (t.length == 1 ? (r = t[0], this.map.forEach(function (t) { n = i.tables[r][t[r]]; u.push(n) })) : this.map.forEach(function (r) { n = {}; t.forEach(function (t) { n[t] = i.tables[t][r[t]] }); u.push(n) })), u } }; gryst.JoinMap.$inject = ["$tables"] }(), function (n) { gryst.extend = function (n, i, r) { r && (i.$inject = r); gryst.Query.prototype[n] = function (n) { var r = t.createOp.call(this, i, n); return this.ops.push(r), this } }; gryst.Query = function () { var n = this; this.tables = {}; this.joinMap = []; this.ops = []; this.result = null; this.injector = new gryst.Injector(this); Object.defineProperty(this, "length", { get: function () { return n.result === null && n.run(), n.result.length } }) }; var t = { createOp: function (n, t) { return t = Array.isArray(t) ? t : [t], this.injector.inject(n, t), new n(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9]) }, addChildSort: function (n) { for (var t = this.ops.length - 1; t >= 0; t--) if (this.ops[t] instanceof gryst.Sort) { this.ops[t].setChild(n); return } this.ops.push(n) }, run: function () { var n = this; return this.joinMap = [], this.result = null, this.ops.forEach(function (t) { n.result = t.run() }), this.result === this.joinMap && (this.result = new gryst.JoinMap(this.joinMap, this.tables).run()), this.result } }; gryst.Query.prototype = { from: function (i, r) { r = r || n.createTableID(this.tables); this.tables[r] = i; var u = t.createOp.call(this, gryst.From, r); return this.ops.push(u), this }, join: function (n, i, r, u) { this.tables[i] = n; var f = t.createOp.call(this, gryst.Join, [r, u]); return this.ops.push(f), this }, where: function (n) { var i = t.createOp.call(this, gryst.Where, n); return this.ops.push(i), this }, orderBy: function (n, i) { var r = t.createOp.call(this, gryst.Sort, [n, !1, i]); return this.ops.push(r), this }, thenBy: function (n, i) { var r = t.createOp.call(this, gryst.Sort, [n, !1, i]); return t.addChildSort.call(this, r), this }, orderByDescending: function (n, i) { var r = t.createOp.call(this, gryst.Sort, [n, !0, i]); return this.ops.push(r), this }, thenByDescending: function (n, i) { var r = t.createOp.call(this, gryst.Sort, [n, !0, i]); return t.addChildSort.call(this, r), this }, group: function (n, i, r) { var u = t.createOp.call(this, gryst.Group, [n, i, r]); return this.ops.push(u), this }, select: function (n, i) { var r = t.createOp.call(this, gryst.Select, [n, i]); return this.ops.push(r), this }, distinct: function (n) { var i = t.createOp.call(this, gryst.Distinct, n); return this.ops.push(i), this }, forEach: function (n) { var t = this, i = this.run(); i.forEach(function (i, r) { n.call(t, i, r) }) }, run: function (n) { if (n != undefined) { var i = this; setTimeout(function () { n(t.run.call(i)) }, 0) } else return t.run.call(this) }, get: function (n) { return this.result === null && this.run(), this.result[n] } } }(gryst.common), function (n) { gryst.Select = function (t, i, r, u, f) { if (this.tables = r, this.getJoinMap = u, this.setJoinMap = f, this.tableID = i, typeof t == "function") { if (this.func = t, this.params = n.getParamNames(t), this.params.length === 0) throw "Select function has no parameters. Select may be omitted if the result needs no modification."; } else if (this.params = t, gryst.common.hasValue(this.params) === !1) throw "Select function has no parameters. Select may be omitted if the result needs no modification."; }; gryst.Select.$inject = ["$tables", "$getJoinMap", "$setJoinMap"]; gryst.Select.prototype = { run: function () { var t = this, i, f, e, o = [], u = this.getJoinMap(), r; return (this.tableID = this.tableID || n.createTableID(this.tables), gryst.log("Select: table ID:" + this.tableID), this.tables[this.tableID] = [], u.length == 0) ? (gryst.log("Select: empty join map"), this.tables[this.tableID]) : (gryst.log("Select: params"), gryst.log(this.params), gryst.log("Select: tables"), gryst.log(this.tables), r = n.getFieldRefs(this.params, this.tables), gryst.log("Select: fields:"), gryst.log(r), this.func ? u.forEach(function (i) { e = n.getArguments(r, i); f = t.func.apply(t, e); t.tables[t.tableID].push(f) }) : u.forEach(function (n) { i = {}; r.length == 1 ? i = r[0].getArgForMapping(n) : r.forEach(function (t) { i[t.name] = t.getArgForMapping(n) }); t.tables[t.tableID].push(i) }), this.tables[this.tableID].forEach(function (n, r) { i = {}; i[t.tableID] = r; o.push(i) }), this.setJoinMap(o), this.tables[this.tableID]) } } }(gryst.common); gryst.extend("skip", function (n, t, i) { this.run = function () { gryst.log("skip: " + n); var r = t().slice(n); return i(r), r } }, ["$getJoinMap", "$setJoinMap"]); gryst.extend("take", function (n, t, i) { this.run = function () { gryst.log("take: " + n); var r = t().slice(0, n); return i(r), r } }, ["$getJoinMap", "$setJoinMap"]), function (n) { gryst.Sort = function (n, t, i, r, u, f) { this.field = n; this.desc = t; this.func = i; this.tables = r; this.getJoinMap = u; this.setJoinMap = f; this.childSort = null; this.type = null; this.fieldRef = null; this.sort = null }; gryst.Sort.$inject = ["$tables", "$getJoinMap", "$setJoinMap"]; var t = { getSortType: function (t) { var r, u, i; if (t.table.length > 0) { for (i = null, r = 0; r < t.table.length && n.isEmpty(i) ; r++) i = t.getArg(r); if (!n.isEmpty(i)) { u = n.getType(i); gryst.log("Sort: key type: "); gryst.log(u); switch (u) { case "number": case "date": case "boolean": return u; default: return "string" } } } }, getSortFunction: function () { var i, n = this; return (gryst.log("Sort: resolving sort function"), this.fieldRef = new gryst.FieldRef(this.field, this.tables), gryst.log("Sort: fieldRef:"), gryst.log(this.fieldRef), this.func != undefined) ? (gryst.log("Sort: using supplied function"), function (t, i) { var u = n.fieldRef.getArgForMapping(t), f = n.fieldRef.getArgForMapping(i), r = n.func(u, f); return r === 0 && n.childSort !== null ? n.childSort.sort(t, i) : r }) : (i = t.getSortType(this.fieldRef), i === "number" || i === "date" || i == "boolean" ? (gryst.log("Sort: sorting by number || date || boolean"), this.desc === !0 ? function (t, i) { var u = n.fieldRef.getArgForMapping(t), f = n.fieldRef.getArgForMapping(i), r = f - u; return r === 0 && n.childSort !== null ? n.childSort.sort(t, i) : r } : function (t, i) { var u = n.fieldRef.getArgForMapping(t), f = n.fieldRef.getArgForMapping(i), r = u - f; return r === 0 && n.childSort !== null ? n.childSort.sort(t, i) : r }) : (gryst.log("Sort: sorting by string"), this.desc === !0 ? function (t, i) { var u = n.fieldRef.getArgForMapping(t), r = n.fieldRef.getArgForMapping(i); if (u === null) { if (r != null) return 1 } else if (r === null) return -1; return u > r ? -1 : u < r ? 1 : n.childSort !== null ? n.childSort.sort(t, i) : 0 } : function (t, i) { var u = n.fieldRef.getArgForMapping(t), r = n.fieldRef.getArgForMapping(i); if (u === null) { if (r != null) return -1 } else if (r === null) return 1; return u > r ? 1 : u < r ? -1 : n.childSort !== null ? n.childSort.sort(t, i) : 0 })) } }; gryst.Sort.prototype = { setChild: function (n) { this.childSort === null ? this.childSort = n : this.childSort.setChild(n) }, init: function () { this.sort = t.getSortFunction.call(this); this.childSort !== null && this.childSort.init() }, run: function () { var n = this.getJoinMap(); return n.length < 2 ? (gryst.log("Sort: empty join map"), n) : (this.init(), gryst.log("Sort: desc: "), gryst.log(this.desc), n.sort(this.sort), n) } } }(gryst.common), function (n) { gryst.Where = function (t, i, r, u) { if (this.tables = i, this.getJoinMap = r, this.setJoinMap = u, this.func = t, this.params = n.getParamNames(t), this.throwIfNoFieldRef = this.params.length > 1, this.params.length === 0) throw "Where function has no parameters."; }; gryst.Where.$inject = ["$tables", "$getJoinMap", "$setJoinMap"]; gryst.Where.prototype = { run: function () { var r = this.getJoinMap(), i, f, e, u, t, o; if (r.length == 0) return gryst.log("Where: empty join map"), r; if (i = [], u = this, gryst.log("Where: throw if no field refs: " + this.throwIfNoFieldRef), t = n.getFieldRefs(this.params, this.tables, this.throwIfNoFieldRef), gryst.log("Where: fieldRefs:"), gryst.log(t), t.length === 1 && t[0].isResolved() === !1) o = Object.getOwnPropertyNames(this.tables).sort().reverse()[0], t[0] = new gryst.FieldRef(o, this.tables); else throw "Could not resolve field references for where clause: " + this.params.toString(); return gryst.log("Where: fieldRefs:"), gryst.log(t), r.forEach(function (r) { f = n.getArguments(t, r); e = u.func.apply(u, f); e === !0 && i.push(r) }), this.setJoinMap(i), i } } }(gryst.common);
//# sourceMappingURL=gryst.min.js.map
