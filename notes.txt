Gryst

Gryst is a query engine for JavaScript. I originally built it for a budgeting dashboard that was designed to download a data payload off the server and then use a client-side querying engine to slice and dice the data inside the browser.

Gryst is different from most other querying protocols you might have encountered because it doesn't require a specific order to the query syntax (select, from, join, where, etc.). Instead, Gryst queries are constructed of operations that are chained together and executed in sequence to create structured result sets. Further, Gryst is extensible. You can create your own custom operations that can be added to Gryst query chains to meet your specific requirements.

Froms and Joins create a master join map consisting of row indexes from each table. The first From does the initial population. Subsequent join operations supplement the map with indexes from other tables by intersecting between common keys. This typically expands the join map when joining on one-to-many relationships because the parent table's indexes are copied for every row in the child table. But it also automatically filters out rows that are not common to both tables. To create a cross join, use multiple "from" functions:

qry.from("c", "Customers").
    from("v", "Vendors").
    where...

The first "from" populates the join map with all the row indexes from the Customers table. Then second "from" iterates through a nested loop, adding indexes from the Vendors table for each index already in the join map.

Once the join map is created, the rest of the operations modify it in some way.

Where clauses take a function as an argument that returns a boolean value. Where clauses iterate over the join map, retrieving the table rows indicated by the map and passing them to the function. If the function returns false, those indexes are removed from the join map.

Sort operations are initialized with a table ID, a field name, and a direction (ascending or descending). A sort can also have a child sort, added by calls to the "thenBy" functions, creating a chain. Each sort is passed a set of indexes from the join map (the first sort is passed the entire map). The sort then retrieves the rows indicated by the indexes and sorts them by the field values. If a sort has a child sort, it splits up its map by the field values to create an array of sub maps which are then handed off to the child sort one at a time. Each child sort does the same thing, sorting its chunk of the join map, splitting it up into more chunks, handing the chunks off to its child sort, and so on. The end result is a sorted join map.

The join map has been created, filtered, and sorted. Next up: grouping. The Group operation takes 3 arguments: group, key, and group ID. The group and key arguments can be a function, a table ID, or a field name. The group ID will be the name used to access your grouping later on. The Group operation is quite flexible. It can group on any JavaScript type, including arbitrary objects and arrays. A group operation creates a completely new join map, overwriting the previous one. But you are free to append additional operations after the grouping such as joins, wheres, sorts, more groups, and selects, all of which should refer to the last group you created.

Next, the Select operation. Use this as a way to "compose" the result and add structure to it. It takes 2 arguments: a function and an optional ID. The select operation iterates through the join map and passes table rows to the function. The function slices and dices the row objects passed in. The returned result is added to a new table, identified by the optional ID you supplied. If an ID isn't specified, gryst creates a unique ID for you. Supplying your own ID is useful if you wish to keep building out the query, because you don't have to stop with the Select operation. You can join more tables, wheres, sorts, etc onto the table you created in your Select operation. You can even add more Selects, creating yet more named table instances that can be queried further. It all just becomes more grist for the mill.

There are a couple more operations we should discuss. But I wanted to save them for last to demonstrate how Gryst can be extended with your own custom operations.

Skip & Take

The 'extend' function can be used to add custom operations to gryst. It takes 3 arguments: the name of the operation, a constructor function containing a 'run' function, and (optionally) an array of strings declaring some injectables. This last argument is a technique borrowed from angular.js. If you minify your code, then you'll need to use the last argument to tell gryst what to inject into your function because most compilers will minimize your function arguments.

I've used the extend function to implement 'skip' and 'take' operations:

gryst.extend("skip", function (count, $getJoinMap, $setJoinMap) {
    this.run = function () {
        var map = $getJoinMap().slice(count);
        $setJoinMap(map);
        return map;
    };
}, ['$getJoinMap', '$setJoinMap']);

gryst.extend("take", function (count, $getJoinMap, $setJoinMap) {
    this.run = function () {
        var map = $getJoinMap().slice(0, count);
        $setJoinMap(map);
        return map;
    };
}, ['$getJoinMap', '$setJoinMap']);


TODO:

Create aggregations.

Get rid of Runnable class.

Modify all common functions so they don't need a reference to the caller.

Add the ability to reference complex property paths: group.Key.TenseID

Add the ability to run queries async with a callback.

Add functions to Sort class.

Make it minify-proof.

Fix Sort class. We need a less clunky way of handling child sorts. Perhaps some kind of sort tree would work. One requirement is that we have to remain key-agnostic. The sort algorithm canâ€™t know about the sort values. Only the mappings and whether they are the same or different are available. So the tree would have to be constructed based on that information. 
